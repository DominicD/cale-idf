#include "epd.h"
#include <stdio.h>
#include <stdlib.h>
#include "esp_log.h"
#include "freertos/task.h"

/*
 The EPD needs a bunch of command/argument values to be initialized.
*/

//Place data into DRAM. Constant data gets placed into DROM by default, which is not accessible by DMA.
//full screen update LUT
DRAM_ATTR static const epd_init_44 lut_20_vcomDC={
0x20, {
  0x00, 0x08, 0x00, 0x00, 0x00, 0x02,
  0x60, 0x28, 0x28, 0x00, 0x00, 0x01,
  0x00, 0x14, 0x00, 0x00, 0x00, 0x01,
  0x00, 0x12, 0x12, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00,
},44};

DRAM_ATTR static const epd_init_42 lut_21_ww={
0x21, {
  0x40, 0x08, 0x00, 0x00, 0x00, 0x02,
  0x90, 0x28, 0x28, 0x00, 0x00, 0x01,
  0x40, 0x14, 0x00, 0x00, 0x00, 0x01,
  0xA0, 0x12, 0x12, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
},42};

DRAM_ATTR static const epd_init_42 lut_22_bw={
0x22,{
  0x40, 0x08, 0x00, 0x00, 0x00, 0x02,
  0x90, 0x28, 0x28, 0x00, 0x00, 0x01,
  0x40, 0x14, 0x00, 0x00, 0x00, 0x01,
  0xA0, 0x12, 0x12, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
},42};

DRAM_ATTR static const epd_init_42 lut_23_wb ={
0x23,{
  0x80, 0x08, 0x00, 0x00, 0x00, 0x02,
  0x90, 0x28, 0x28, 0x00, 0x00, 0x01,
  0x80, 0x14, 0x00, 0x00, 0x00, 0x01,
  0x50, 0x12, 0x12, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
},42};

DRAM_ATTR static const epd_init_42 lut_24_bb ={
0x24,{
  0x80, 0x08, 0x00, 0x00, 0x00, 0x02,
  0x90, 0x28, 0x28, 0x00, 0x00, 0x01,
  0x80, 0x14, 0x00, 0x00, 0x00, 0x01,
  0x50, 0x12, 0x12, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
},42};

static const epd_power_5 epd_wakeup_power ={
0x01,{0x03,0x00,0x2b,0x2b,0x03}
};

static const epd_init_3 epd_soft_start ={
0x06,{0x17,0x17,0x17}
};

static const epd_init_2 epd_panel_setting ={
0x00,{0xbf,0x0d}
};

static const epd_init_1 epd_pll ={
0x30,{0x3a}
};

static const epd_init_3 epd_resolution ={
0x61,{GxGDEW0213I5F_WIDTH,
GxGDEW0213I5F_HEIGHT >> 8,
GxGDEW0213I5F_HEIGHT & 0xFF
}};

//partial screen update LUT
//#define Tx19 0x19 // original value is 25 (phase length)
#define Tx19 0x28   // new value for test is 40 (phase length)
/* const unsigned char Epd::lut_20_vcomDC_partial[] =
{
  0x00, Tx19, 0x01, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00,
};

const unsigned char Epd::lut_21_ww_partial[] =
{
  0x00, Tx19, 0x01, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char Epd::lut_22_bw_partial[] =
{
  0x80, Tx19, 0x01, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char Epd::lut_23_wb_partial[] =
{
  0x40, Tx19, 0x01, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char Epd::lut_24_bb_partial[] =
{
  0x00, Tx19, 0x01, 0x00, 0x00, 0x01,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
}; */

// Partial Update Delay, may have an influence on degradation
#define GxGDEW0213I5F_PU_DELAY 100

spi_device_handle_t spi;

//Constructor
Epd::Epd(EspSpi& dio):Adafruit_GFX(GxGDEW0213I5F_WIDTH, GxGDEW0213I5F_HEIGHT), IO(dio) {
  IO = dio;
  printf("Epd() constructor extends Adafruit_GFX(%d,%d)\n",
  GxGDEW0213I5F_WIDTH, GxGDEW0213I5F_HEIGHT);  
}

void Epd::initFullUpdate(){
    IO.cmd(0x82);  //vcom_DC setting
    IO.data(0x08);

    IO.cmd(0X50); //VCOM AND DATA INTERVAL SETTING
    IO.data(0x97);    //WBmode:VBDF 17|D7 VBDW 97 VBDB 57

    IO.cmd(lut_20_vcomDC.cmd);
    IO.data(lut_20_vcomDC.data,lut_20_vcomDC.databytes);
   
    IO.cmd(lut_21_ww.cmd);
    IO.data(lut_21_ww.data,lut_21_ww.databytes);

    IO.cmd(lut_22_bw.cmd);
    IO.data(lut_22_bw.data,lut_22_bw.databytes);

    IO.cmd(lut_23_wb.cmd);
    IO.data(lut_23_wb.data,lut_23_wb.databytes);

    IO.cmd(lut_24_bb.cmd);
    IO.data(lut_24_bb.data,lut_24_bb.databytes);
    printf("initFullUpdate() LUT\n");
}

//Initialize the display
void Epd::init(bool debug)
{
    //Initialize the Epaper and reset it
    IO.init();
   
    //Initialize the Epaper and reset it
        debug_enabled = debug;
     if (debug_enabled) {
        printf("Epd::init(%d)\n", debug);
    } 

    //Reset the display
    IO.reset();

    fillScreen(GxEPD_WHITE);
    _using_partial_mode = false;
}

void Epd::fillScreen(uint16_t color)
{
  uint8_t data = (color == GxEPD_WHITE) ? 0xFF : 0x00;
  for (uint16_t x = 0; x < sizeof(_buffer); x++)
  {
    _buffer[x] = data;
  }

  printf("fillScreen(%d) _buffer len:%d\n",data,sizeof(_buffer));
}

void Epd::_wakeUp(){
    //if (_rst >= 0) {
      IO.reset();
    //}

  IO.cmd(epd_wakeup_power.cmd);
  IO.data(epd_wakeup_power.data,5);
  
  IO.cmd(epd_soft_start.cmd);
  IO.data(epd_soft_start.data,3);
  IO.cmd(0x04);
  _waitBusy("epd_wakeup_power");

  // [1] LUT from register, 128x296
  // [2] VCOM to 0V fast
  IO.cmd(epd_panel_setting.cmd);
  IO.data(epd_panel_setting.data,2);

  // 3a 100HZ   29 150Hz 39 200HZ 31 171HZ
  IO.cmd(epd_pll.cmd);
  IO.data(epd_pll.data,1);   

  //resolution setting
  IO.cmd(epd_resolution.cmd);
  IO.data(epd_resolution.data,3);

  initFullUpdate();
}

void Epd::update()
{
  _using_partial_mode = false;
  _wakeUp();

  IO.cmd(0x10);

  // In GxEPD here it wrote the full buffer with 0xFF
  // Note doing it like this is not refreshing
  /* uint8_t _wbuffer[GxGDEW0213I5F_BUFFER_SIZE];
    for (uint16_t x = 0; x < GxGDEW0213I5F_BUFFER_SIZE; x++)
  {
    _wbuffer[x] = 0xFF;
  }
  data(_wbuffer, sizeof(_wbuffer)); */
  
  IO.cmd(0x13);

  IO.data(_buffer,sizeof(_buffer));

  IO.cmd(0x12);
  _waitBusy("update");
  _sleep();
}

void Epd::_waitBusy(const char* message){
  ESP_LOGI(TAG, "_waitBusy for %s", message);
  int64_t time_since_boot = esp_timer_get_time();

  while (1){
    if (gpio_get_level((gpio_num_t)CONFIG_EINK_BUSY) == 1) break;
    vTaskDelay(1);
    if (esp_timer_get_time()-time_since_boot>1800000)
    {
      if (debug_enabled) ESP_LOGI(TAG, "Busy Timeout");
      break;
    }
  }
}

void Epd::_sleep(){
  IO.cmd(0x02); // power off display
  _waitBusy("power_off");
  IO.cmd(0x07); // deep sleep
  IO.data(0xa5);
}

void Epd::drawPixel(int16_t x, int16_t y, uint16_t color) {
  //printf("Epd drawPixel(%d,%d)\n",x,y);
  if ((x < 0) || (x >= width()) || (y < 0) || (y >= height())) return;

  // check rotation, move pixel around if necessary
  switch (getRotation())
  {
    case 1:
      swap(x, y);
      x = GxGDEW0213I5F_WIDTH - x - 1;
      break;
    case 2:
      x = GxGDEW0213I5F_WIDTH - x - 1;
      y = GxGDEW0213I5F_HEIGHT - y - 1;
      break;
    case 3:
      swap(x, y);
      y = GxGDEW0213I5F_HEIGHT - y - 1;
      break;
  }
  uint16_t i = x / 8 + y * GxGDEW0213I5F_WIDTH / 8;
  // Todo research what is for _current_page
  if (_current_page < 1)
  {
    if (i >= sizeof(_buffer)) return;
  }
  else
  {
    y -= _current_page * GxGDEW0213I5F_PAGE_HEIGHT;
    if ((y < 0) || (y >= GxGDEW0213I5F_PAGE_HEIGHT)) return;
    i = x / 8 + y * GxGDEW0213I5F_WIDTH / 8;
  }

  if (color)
    _buffer[i] = (_buffer[i] | (1 << (7 - x % 8)));
  else
    _buffer[i] = (_buffer[i] & (0xFF ^ (1 << (7 - x % 8))));
}

size_t Epd::write(uint8_t v){
  Adafruit_GFX::write(v);
  return 1;
}

void Epd::print(const std::string& text){
   for(auto c : text) {
     write(uint8_t(c));
   }
}

void Epd::println(const std::string& text){
   for(auto c : text) {
     write(uint8_t(c));
   }
   write(10); // newline
}
